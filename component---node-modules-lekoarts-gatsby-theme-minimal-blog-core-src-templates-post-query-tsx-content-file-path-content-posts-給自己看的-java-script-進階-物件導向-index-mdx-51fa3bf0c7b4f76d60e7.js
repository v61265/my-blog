"use strict";(self.webpackChunkv61265_blog=self.webpackChunkv61265_blog||[]).push([[700],{1173:function(e,n,t){t.d(n,{p:function(){return p},A:function(){return g}});var l=t(6540),a=t(557),o=t(6835),c=t(3328),r=t(7715),m=t(7169);var s=e=>{let{post:n}=e;return null};const u=["16px","8px","4px"].map((e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px"));var i=e=>{let{data:{post:n},children:t}=e;return(0,a.Y)(c.A,null,(0,a.Y)(o.DZ,{as:"h1",variant:"styles.h1"},n.title),(0,a.Y)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,a.Y)("time",null,n.date),n.tags&&(0,a.Y)(l.Fragment,null," — ",(0,a.Y)(r.A,{tags:n.tags})),n.timeToRead&&" — ",n.timeToRead&&(0,a.Y)("span",null,n.timeToRead," min read")),(0,a.Y)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:u.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},t),(0,a.Y)(s,{post:n}))};const p=e=>{var n,t,l;let{data:{post:o}}=e;return(0,a.Y)(m.A,{title:o.title,description:o.description?o.description:o.excerpt,image:o.banner?null===(n=o.banner)||void 0===n||null===(t=n.childImageSharp)||void 0===t||null===(l=t.resize)||void 0===l?void 0:l.src:void 0,pathname:o.slug,canonicalUrl:o.canonicalUrl})};function g(e){let{...n}=e;return l.createElement(i,n)}},7715:function(e,n,t){var l=t(557),a=t(6540),o=t(4194),c=t(3601),r=t(2174);n.A=e=>{let{tags:n}=e;const{tagsPath:t,basePath:m}=(0,c.A)();return(0,l.Y)(a.Fragment,null,n.map(((e,n)=>(0,l.Y)(a.Fragment,{key:e.slug},!!n&&", ",(0,l.Y)(o.Link,{sx:e=>{var n;return{...null===(n=e.styles)||void 0===n?void 0:n.a}},to:(0,r.A)("/"+m+"/"+t+"/"+e.slug)},e.name)))))}},7169:function(e,n,t){var l=t(6540),a=t(4194),o=t(7533);n.A=e=>{let{title:n="",description:t="",pathname:c="",image:r="",children:m=null,canonicalUrl:s=""}=e;const u=(0,o.A)(),{siteTitle:i,siteTitleAlt:p,siteUrl:g,siteDescription:E,siteImage:d,author:j,siteLanguage:y}=u,h={title:n?n+" | "+i:p,description:t||E,url:""+g+(c||""),image:""+g+(r||d)};return l.createElement(l.Fragment,null,l.createElement("html",{lang:y}),l.createElement("title",null,h.title),l.createElement("meta",{name:"description",content:h.description}),l.createElement("meta",{name:"image",content:h.image}),l.createElement("meta",{property:"og:title",content:h.title}),l.createElement("meta",{property:"og:url",content:h.url}),l.createElement("meta",{property:"og:description",content:h.description}),l.createElement("meta",{property:"og:image",content:h.image}),l.createElement("meta",{property:"og:type",content:"website"}),l.createElement("meta",{property:"og:image:alt",content:h.description}),l.createElement("meta",{name:"twitter:card",content:"summary_large_image"}),l.createElement("meta",{name:"twitter:title",content:h.title}),l.createElement("meta",{name:"twitter:url",content:h.url}),l.createElement("meta",{name:"twitter:description",content:h.description}),l.createElement("meta",{name:"twitter:image",content:h.image}),l.createElement("meta",{name:"twitter:image:alt",content:h.description}),l.createElement("meta",{name:"twitter:creator",content:j}),l.createElement("meta",{name:"gatsby-theme",content:"@lekoarts/gatsby-theme-minimal-blog"}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"32x32",href:(0,a.withPrefix)("/favicon-32x32.png")}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"16x16",href:(0,a.withPrefix)("/favicon-16x16.png")}),l.createElement("link",{rel:"apple-touch-icon",sizes:"180x180",href:(0,a.withPrefix)("/apple-touch-icon.png")}),s?l.createElement("link",{rel:"canonical",href:s}):null,m)}},9969:function(e,n,t){t.r(n),t.d(n,{Head:function(){return r.p},default:function(){return m}});var l=t(6540),a=t(8453);function o(e){const n=Object.assign({p:"p",a:"a",h3:"h3",pre:"pre",code:"code",strong:"strong",ol:"ol",li:"li",img:"img",h4:"h4"},(0,a.RP)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.p,null,"給自己看的 JS 進階：（建議按照順序看）\n",l.createElement(n.a,{href:"/JavaScript-advanced-variable"},"給自己看的 JS 進階－變數"),"\n",l.createElement(n.a,{href:"/JavaScript-advanced-hoisting"},"給自己看的 JS 進階－Hoisting"),"\n",l.createElement(n.a,{href:"/JavaScript-advanced-closure"},"給自己看的 JS 進階－Closure"),"\n",l.createElement(n.a,{href:"JavaScript-advanced-oop"},"給自己看的 JS 進階－物件導向")),"\n",l.createElement(n.h3,null,"什麼是物件導向"),"\n",l.createElement(n.p,null,"從剛剛的例子開始說吧："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function createWallet(init) {\n\tvar money = init\n\treturn {\n\t\tadd: function(num) {\n\t\t\tmoney += num\n\t\t},\n\t\tdeduct: function(num) {\n\t\t\tmoney -= num\n\t\t}\n\t}, getMoney() {\n\t\treturn money\n\t}\n}\n\nvar myWallet = createWallet(99)\nmyWallet.add(1)\nmyWallet.deduct(10)\nconsole.log(myWallet.getMoney()) // 90\n")),"\n",l.createElement(n.p,null,"這個例子中回傳的值是一個物件，其實就算是物件導向。在使用 JS 時，也時常不是直接 call 一個 function ，而是對某個物件做操作，這種做法的好處是方便模組化。"),"\n",l.createElement(n.h3,null,"class"),"\n",l.createElement(n.p,null,"從 ES6 的 ",l.createElement(n.code,null,"class")," 開始談起。"),"\n",l.createElement(n.p,null,"首先， class 的名稱一定是大寫開頭，例如："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"class Dog {\n  sayHello() {\n    console.log('hello');\n  }\n}\n")),"\n",l.createElement(n.p,null,"class 有點像設計圖，當我們實際使用前時，要用 ",l.createElement(n.code,null,"new")," 將 class 實體化 (instance)："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"var d = new Dog();\nd.sayHello(); // hello\n")),"\n",l.createElement(n.p,null,"另一個概念是 ",l.createElement(n.code,null,"this")," ，它會指向呼叫它的東西："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"class Dog {\n  setName(name) {\n    this.name = name;\n  }\n  getName() {\n    return this.name;\n  }\n}\n\nvar d = new Dog();\nd.setName('jojo');\nconsole.log(getName()); // jojo\n")),"\n",l.createElement(n.p,null,"上面範例中 ",l.createElement(n.code,null,"d.setName('jojo')")," 中的 ",l.createElement(n.code,null,"this")," 因為是由 d 呼喚的，因此 ",l.createElement(n.code,null,"this")," 當然就指向變數 d 。\nclass 中 ",l.createElement(n.code,null,"setName(name)")," 這樣的函數被稱為 setter ，讓裡面存取到外面的值；而 ",l.createElement(n.code,null,"sayHello()")," 則叫 getter ，是讓外面得到 class 的值。 另外我們也可以直接這樣寫："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"d.name = 'dio';\nconsole.log(d.name); // dio\n")),"\n",l.createElement(n.p,null,"但還是建議用 setter 和 getter 。"),"\n",l.createElement(n.p,null,"如果想要用像是函式傳參數的方式設定，可以用 ",l.createElement(n.code,null,"建構子 constructor"),"："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"class Dog {\n  constructor(name) {\n    this.name = name;\n  }\n  getName() {\n    return this.name;\n  }\n}\n\nvar d = new Dog('jojo'); // 字串 'jojo' 被傳入 constructor() 中\nconsole.log(getName()); // jojo\n\nvar d = new Dog('dio');\nconsole.log(getName()); // dio\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"ES5 的 class")),"\n",l.createElement(n.p,null,"在 ES5 中沒有 class ，因此要這樣寫："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function Dog(name) {\n\tvar myName = name\n\treturn {\n\t\tgetName: function() {\n\t\t\treturn myName\n\t\t},\n\t\tsayHello: funcrion() {\n\t\t\tconsole.log(myName)\n\t\t}\n\t}\n}\n\nvar d = Dog('jojo')\nd.sayHello // jojo\n\nvar b = Dog('dio')\nd.sayHello // dio\n")),"\n",l.createElement(n.p,null,"不過因為每次都是呼叫一個新的物件，會出現這種狀況："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"console.log(b.sayHello === d.sayHello); // false\n")),"\n",l.createElement(n.p,null,"不過兩個是同個 function ，所以共用同個 function 比較省記憶體吧？"),"\n",l.createElement(n.p,null,"因此在 ES5 中，可以將 function 當作 constructor 用："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function Dog(name) {\n  this.name = name;\n}\n\nvar d = new Dog('abc');\nconsole.log(d); // Dog { name: 'abc' }\n")),"\n",l.createElement(n.p,null,"自動變成物件了！\n不過這樣要怎麼知道是 constructor 還是平常的 function？只有加 ",l.createElement(n.code,null,"new")," 才會被認定是 constructor ，如果沒加就是 function 。"),"\n",l.createElement(n.p,null,"設定屬性的問題搞定了，但要怎麼設定輸出名字和其他操作ㄋ？這時候可以把東西掛在 ",l.createElement(n.code,null,".prototype")," 上："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"Dog.prototype.sayHello = function () {\n  console.log(this.name);\n};\n\nvar d = new Dog('jojo');\nd.sayHello; // jojo\n")),"\n",l.createElement(n.h3,null,"Prototype"),"\n",l.createElement(n.p,null,"JavaScript 中，每個變數都有個隱藏屬性 ",l.createElement(n.code,null,"__proto__")," ，暗示如果在 ",l.createElement(n.code,null,"d")," 上面找不到 ",l.createElement(n.code,null,"sayHello")," 的屬性："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function Dog(name) {\n  this.name = name;\n}\n\nDog.prototype.sayHello = function () {\n  console.log(this.name);\n};\n\nvar d = new Dog('jojo');\nd.sayHello; // jojo\n\nconsole.log(d.__proto__);\n// Dog { sayHello: [Function (anonymous)] }\n// 其實就是 Dog.prototype\n")),"\n",l.createElement(n.p,null,"當我們呼叫 ",l.createElement(n.code,null,"d.sayHello")," 時，我們其實是做了："),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.code,null,"d")," 本身是否有 ",l.createElement(n.code,null,"sayHello")),"\n",l.createElement(n.li,null,l.createElement(n.code,null,"d.__proto__")," 是否有 ",l.createElement(n.code,null,"sayHello")," ，也就是 ",l.createElement(n.code,null,"Dog.prototype")),"\n",l.createElement(n.li,null,"沒有的話就找 ",l.createElement(n.code,null,"d.__proto__.__proto__")," ，也就是 ",l.createElement(n.code,null,"Object.prototype")),"\n",l.createElement(n.li,null,"如果還是沒有就找 ",l.createElement(n.code,null,"d.__proto__.__proto__.__proto__")," ，沒有的話會回傳 null。"),"\n",l.createElement(n.li,null,"null 代表找到頂了，沒有的話就會拋出錯誤。"),"\n"),"\n",l.createElement(n.p,null,"以上都是只要有就會回傳值，沒有的話才往下進行，這個步驟被稱為原型練（Prototype Chain）。"),"\n",l.createElement(n.img,{src:"https://4.bp.blogspot.com/-fatzOLLqlGM/V2dXLiCs5RI/AAAAAAAAmwE/PLkLHJTmOkIiIz0ftJVdsdWmVhzJqgt8wCLcB/s640/1.png",alt:""}),"\n",l.createElement(n.img,{src:"https://i.ibb.co/WVymhkR/prototype.png",alt:""}),"\n",l.createElement(n.p,null,"我們來看一下："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"console.log(d.__proto__);\n// Dog.prototype\n// 結果：Dog { sayHello: [Function (anonymous)] }\nconsole.log(d.__proto__.__proto__);\n// Dog.prototype.__proto__\n// Object.prototype\n// 結果：{}\nconsole.log(d.__proto__.__proto__.__proto__);\n// null\n")),"\n",l.createElement(n.p,null,"他們之間的關係如下："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"d.__proto__ = Dog.prototype;\nd.__proto__.__proto__ = Object.prototype;\nDog.prototype.__proto__ = Object.prototype;\n")),"\n",l.createElement(n.p,null,"因此我們也可以設定 Object 的 prototype ，這樣就會在第三個步驟呼叫到結果："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"Object.prototype.sayHello = function () {\n  console.log('object', this.name);\n};\n\nvar d = new Dog('jojo');\nd.sayHello; // object jojo\n")),"\n",l.createElement(n.p,null,"如果同時設定 Object 和 Dog 的 prototype ，則會因為原型鍊會先選到 Dog 的："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"Dog.prototype.sayHello = function () {\n  console.log(this.name);\n};\n\nObject.prototype.sayHello = function () {\n  console.log('object', this.name);\n};\n\nvar d = new Dog('jojo');\nd.sayHello; // jojo\n")),"\n",l.createElement(n.p,null,"同理，此處的 Object 如果被換成 Function ，第四個步驟就會被換成 Function.prototype 。"),"\n",l.createElement(n.h3,null,"new 到底做了什麼"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"function.call()")," 這個函數可以指定 function 中的 ",l.createElement(n.code,null,"this")," 值："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function test() {\n  console.log(this);\n}\n\ntest.call(123); // [Number: 123]\n")),"\n",l.createElement(n.p,null,"接著來拆解 ",l.createElement(n.code,null,"new")," 到底幫我們做了甚麼，因此用另一個 function 來模擬："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function newDog(name) {\n  // 模擬 new 做了一些事情\n}\n\n// 最後目標\nvar a = newDog('jojo');\na.sayHello(); // 印出 jojo\n")),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"建立一個 object，並將值傳入"),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function newDog(name) {\n  var obj = {};\n  Dog.call(obj, name); // 第一個是 this ，後面依序是傳入值\n  console.log(obj);\n}\n\nvar a = newDog('jojo'); //{ name: 'jojo' }\n")),"\n",l.createElement(n.ol,{start:"2"},"\n",l.createElement(n.li,null,"設定 prototype 連結"),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function newDog(name) {\n  var obj = {};\n  Dog.call(obj, name); // 第一個是 this ，後面依序是傳入值\n  obj.__proto__ = Dog.prototype;\n}\n\nvar a = newDog('jojo');\n")),"\n",l.createElement(n.ol,{start:"3"},"\n",l.createElement(n.li,null,"回傳 object"),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function newDog(name) {\n  var obj = {};\n  Dog.call(obj, name); // 第一個是 this ，後面依序是傳入值\n  obj.__proto__ = Dog.prototype;\n  return obj;\n}\n\nvar a = newDog('jojo');\na.sayHello(); // 印出 jojo\n")),"\n",l.createElement(n.p,null,"就完成ㄌ！"),"\n",l.createElement(n.h3,null,"Inheritance"),"\n",l.createElement(n.p,null,"設想有一個狗的 class ，今天我需要設定黑狗和白狗，這時有名字、會叫、丟飛盤會去接回來之類的和狗有關的屬性就不用再設定一次了。要是有人問你「黑狗有幾個眼睛」時，只要回頭查看「狗」的條目就可以了。這就是 ",l.createElement(n.code,null,"Inheritance")," 繼承的概念。"),"\n",l.createElement(n.p,null,"ES6 中的繼承可以這樣寫："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"class BlackDog extands Dog{\n\t// 其他黑狗的屬性\n}\n\nconst d = BlackDog('jojo')\nd.sayHello()\n")),"\n",l.createElement(n.p,null,"上面的例子中 ",l.createElement(n.code,null,"d.sayHello()")," 實際上是往上找到 Dog 的屬性。"),"\n",l.createElement(n.p,null,"此時若我們想讓黑狗被建立的時候就呼叫 ",l.createElement(n.code,null,"sayHello()"),"："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"class BlackDog extands Dog{\n\tconstructure() {\n\t\tthis.sayHello()\n\t}\n}\n\nconst d = BlackDog('jojo')\n")),"\n",l.createElement(n.p,null,"這樣會噴錯，因為在 ",l.createElement(n.code,null,"constructor")," 中呼叫 ",l.createElement(n.code,null,"this")," 前要用 ",l.createElement(n.code,null,"super()")," 另外引入上一層的",l.createElement(n.code,null,"constructor")," ，如下："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"class BlackDog extands Dog{\n\tconstructure(name) {\n\t\tsuper(name)\n\t\tthis.sayHello()\n\t}\n}\n\nconst d = BlackDog('jojo') // jojo\n")),"\n",l.createElement(n.h3,null,"this"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"this")," 在物件導向中被使用，可以用代表其所對應到的 instance 。"),"\n",l.createElement(n.p,null,"如果直接呼叫 ",l.createElement(n.code,null,"this")," 例如："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function test() {\n  console.log(this);\n}\n\ntest();\n")),"\n",l.createElement(n.p,null,"會出現一長串的東西。"),"\n",l.createElement(n.p,null,"若不是物件導向的環境下，預設值為 Global ，node.js 跑是 ",l.createElement(n.code,null,"global")," 的變數，瀏覽器則是 ",l.createElement(n.code,null,"window")," 。也可以在檔案最上方輸入 ",l.createElement(n.code,null,"'use strict';")," 進入嚴格模式，此時的預設值就會是 ",l.createElement(n.code,null,"undefined")," 。"),"\n",l.createElement(n.p,null,"另一個例外是使用 DOM 的時候："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"document.querySelector('.dom').addEventListener('click', function () {\n  console.log(this); // 點擊到的東西\n});\n")),"\n",l.createElement(n.h3,null,"call 和 apply"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,".call()")," 的第一個值被預設為 this 的值："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function test() {\n  console.log(this);\n}\n\ntest.call(123); // [Number: 123]\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"apply")," 也是："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function test() {\n  console.log(this);\n}\n\ntest.apply(123); // [Number: 123]\n")),"\n",l.createElement(n.p,null,"兩個的差別是後面的參數引入的方法， call 就是用逗號連接，但 apply 只有兩個參數，第二個參數則是將要傳入的參數們用陣列包起來。"),"\n",l.createElement(n.h4,null,"怎麼看 this"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"const obj = {\n  a: 123,\n  test: function () {\n    console.log(this);\n  },\n};\n\nobj.test(); // this 對應到 obj 本身\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"this")," 和放在哪裡無關，而是看呼叫的方法。例如以下寫法雖然一樣，結果卻不同："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"const obj = {\n  a: 123,\n  test: function () {\n    console.log(this);\n  },\n};\n\nconst func = obj.test;\nfunc(); // undefined\n")),"\n",l.createElement(n.p,null,"因為第一個寫法 ",l.createElement(n.code,null,"obj.test()")," 可被視為 ",l.createElement(n.code,null,"obj.test.call(obj)")," ，因此會呼叫到 obj 。"),"\n",l.createElement(n.h4,null,"bind"),"\n",l.createElement(n.p,null,"小小練習，自己先猜猜看答案："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"function log() {\n  console.log(this);\n}\n\nvar a = { a: 1, log: log };\nvar b = { a: 2, log: log };\n\nlog(); // global\na.log(); // a\n\nb.log.apply(a); // a，因為 call 的值優先\n")),"\n",l.createElement(n.p,null,"如果希望不管怎麼呼叫， this 的值都不會變，可以是用 ",l.createElement(n.code,null,".bind()")," ："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"const bindTest = obj.test.bind(obj);\n")),"\n",l.createElement(n.p,null,"之後不管從哪裡呼叫 ",l.createElement(n.code,null,"bindTest()")," ， this 的結果都是 obj 。"),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"bind")," 和 ",l.createElement(n.code,null,"call")," / ",l.createElement(n.code,null,"apply")," 的差別在於，前者會回傳一個新的 function ，後者則是直接呼叫。"),"\n",l.createElement(n.h4,null,"碰到箭頭函式，一切都不一樣ㄌ"),"\n",l.createElement(n.p,null,"使用到箭頭函式時， this 的值和如何呼叫沒有關係，此時的規則和 scope 比較像，也就是和定義在哪裡有關係。"),"\n",l.createElement(n.p,null,"可以看這個例子："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"class Test {\n  run() {\n    consoel.log(this); // Test\n    setTimeOut(function () {\n      console.log(this); // unefined\n    }, 1000);\n  }\n}\n\nconst t = newTest();\nt.run();\n")),"\n",l.createElement(n.p,null,"但如果用箭頭函式："),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"class Test {\n  run() {\n    consoel.log(this); // Test\n    setTimeOut(() => {\n      console.log(this); // Test\n    }, 1000);\n  }\n}\n\nconst t = newTest();\nt.run();\n")))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.RP)(),e.components);return n?l.createElement(n,e,l.createElement(o,e)):o(e)},r=t(1173);function m(e){return l.createElement(r.A,e,l.createElement(c,e))}r.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-給自己看的-java-script-進階-物件導向-index-mdx-51fa3bf0c7b4f76d60e7.js.map